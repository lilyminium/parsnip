
from MDAnalysis.topology.ITPParser import GmxTopIterator
from MDAnalysis.lib.util import openany

from .. import TOPOLOGY_TYPES
from .base import BaseReader, BaseWriter

class ITPWriter(BaseWriter):
    formats = ["ITP"]

    def write(self, topology):
        lines = ["; Topology generated by PolyTop", ";"]
        lines += self.get_moleculetype(topology)
        lines += self.get_atoms(topology)
        lines += self.get_params(topology, "bonds")
        lines += self.get_params(topology, "angles")
        lines += self.get_params(topology, "dihedrals")
        lines += self.get_params(topology, "impropers", directive="dihedrals")
        lines += self.get_params(topology, "pairs")
        lines += self.get_params(topology, "exclusions")

        with open(self.filename, 'w') as f:
            f.write("\n".join(lines))

    @staticmethod
    def get_moleculetype(topology):
        return ["[ moleculetype ]",
                "; Name   nrexcl",
                f"{topology.name:8} {topology.nrexcl}\n"]

    @staticmethod
    def get_atoms(topology):
        line = ("{atom.serial:>5d} {atom.type.id:>6} {atom.resid:>8d}"
                "{atom.resname:>6} {atom.name:>6} {atom.charge_group:>6}"
                "{atom.charge:>7.3f} {atom.mass:>7.4f}")

        header = (";    nr   type    resnr  resid"
                  "   atom   cgnr  charge    mass")
        charge = 0

        lines = ["[ atoms ]", header]
        for a in topology.atoms:
            lines.append(line.format(atom=a))
            charge += a.charge
        lines.append(f"; total charge of molecule: {charge}")
        lines.append("")
        return lines
    
    @staticmethod
    def get_params(topology, param_name, directive=None):
        letters = "ijkl"

        header = ";"
        if len(topology.params[param_name]):
            first = topology.params[param_name][0]
            header += " ".join(["   a{} ".format(x) for x in letters[:first.n_atoms]])
            if first.type is not None:
                header += first.type.short_header_to_string()
        
        if directive is None:
            directive = param_name
        
        lines = [f"[ {directive} ]", header]

        for p in topology.params[param_name]:
            line = " ".join(["{:>6d}".format(i+1) for i in p.indices])
            if p.type is not None:
                line += "{:>4d} ".format(p.type.funct)
                line +=  p.type.to_string()
            lines.append(line)

        lines.append("")
        return lines

    def get_bonds(self, topology):
        return self.get_params(topology.bonds)



class ITPReader(BaseReader):

    formats = ["ITP"]

    atom_fields = ("serial", "atomtype", "resid", "resname",
                   "name", "charge_group", "charge", "mass")

    def __init__(self, *args, **kwargs):
        super(ITPReader, self).__init__(*args, **kwargs)
        self.current_mol = None

        # TODO: settles, constraints, virtual_sites

        self.parsers = {
            'atoms': self.parse_atoms,
            'bonds': self.parse_bonds,
            'angles': self.parse_angles,
            'dihedrals': self.parse_dihedrals,
            'pairs': self.parse_pairs,
            'exclusions': self.parse_exclusions,
        }

    def parse(self, include_dir='/usr/local/gromacs/share/gromacs/top/',
              defined={}):
        import os
        with openany(self.filename) as itp:
            self.lines = GmxTopIterator(itp, include_dir, defined)
            for line in self.lines:
                if '[' in line and ']' in line:
                    section = line.split('[')[1].split(']')[0].strip()

                    if section == 'moleculetype':
                        self.parser = self.parse_moleculetype
                    
                    elif self.current_mol is not None:
                        self.parser = self.parsers.get(section, self._pass)
                    
                    else:
                        self.parser = self._pass
                
                else:
                    self.parser(line)
        
        return self.forcefield

    def parse_moleculetype(self, line):
        name, nrexcl = line.split()[:2]
        mol = self.forcefield._add_mol_topology(name, nrexcl=int(nrexcl))
        self.current_mol = mol
        self.current_resid = None

    def parse_atoms(self, line):
        # ;  nr  type  resnr  resid  atom  cgnr  charge    mass
        atom_kwargs = {k:v for k, v in zip(self.atom_fields, line.split())}
        rid = atom_kwargs.pop("resid")
        rname = atom_kwargs.pop("resname")
        if rid != self.current_resid:
            self.current_res = self.current_mol.add_residue(name=rname, resid=rid)
            self.current_resid = rid
        atom_kwargs["serial"] = int(atom_kwargs["serial"])
        atom_kwargs["charge"] = float(atom_kwargs["charge"])
        atom_kwargs["mass"] = float(atom_kwargs["mass"])
        self.current_res.add_atom(**atom_kwargs)

    def parse_bonds(self, line):
        self._parse_params(line, directive="bonds", n_atoms=2)

    def parse_pairs(self, line):
        self._parse_params(line, directive="pairs", n_atoms=2)

    def parse_angles(self, line):
        self._parse_params(line, directive="angles", n_atoms=3)

    def parse_dihedrals(self, line):
        self._parse_params(line, directive="dihedrals", n_atoms=4)

    def parse_exclusions(self, line):
        serials = list(map(int, line.split()))
        first = serials.pop(0)
        for other in serials:
            pair = tuple(sorted([first, other]))
            self.current_mol.params.add("exclusions", indices=pair)

    def _parse_params(self, line, directive="bonds", n_atoms=2):
        fields = line.split()
        funct = int(fields[n_atoms])
        serials = list(map(int, fields[:n_atoms]))
        param_fields = fields[n_atoms+1:]

        if directive == "dihedrals" and funct in (2, 4):
            directive = "impropers"

        indices = self.current_mol.get_indices_from_serial(serials)
        param = TOPOLOGY_TYPES[directive][funct](*param_fields)

        self.current_mol.params.add(directive, indices=indices,
                                    paramtype=param)

    def _pass(self, line):
        pass